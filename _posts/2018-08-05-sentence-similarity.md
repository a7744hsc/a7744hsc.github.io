---
layout: post
title:  "NLP中的句子相似度计算"
date:   2018-08-05 01:00:00 +0800
categories: NLP
---
自然语言处理是各种机器学习方向中应用前景最广的一个方向，同时也是最有挑战的一个方向。自然语言处理的终极目标是让计算机理解人类所使用的语言。但是由于人类语言的多样性，语义的多样性等原因使得这一目标复杂度极高，目前还无法直接建模和解决。为了解决这个问题，科学家把自然语言处理分成了很多子问题进行处理，相似度计算这些子任务中的一种。

文本的相似度又分为词级别的相似度，句子级别相似度和文章级别的相似度。词级别的相似度计算相对容易，从几十年前人们建立的WordNet字典到近几年十分火热的Word2Vec都是用来解决词与词之间相似度的问题。尤其是随着各种词向量的出现，词级别的相似度问题已经得到了较好的解决。不过句子和文章由于复杂的更高，包含的信息更多，其相似度问题还没有一个非常完善的解决方案，本文就将介绍几种现有几种句子level相似度方法。

1. 直接使用词向量平均值表示短语

    前面我们说过利用词向量对词和词之间的相似度进行计算已经比较完善，准确率也很高。那么如果对一句话中的每个词的词向量求平均值，那么这个向量也应该能表示句子的意思。出于这个思路就有了这一种句子相似度比较方法。这种方法实现起来非常简单，但是也忽略了很多句子原有的重要信息，所以一般会被用做Baseline。

2. Word Mover’s Distance
   
   另一种计算句子之间相似度的放法叫做[Word Mover‘ Distance ](http://proceedings.mlr.press/v37/kusnerb15.pdf)。该方法的思路是记录一句话中每个词与另一句话中距离最短的词，并将该距离作为两句话之间相似度的度量（词与词之间的距离仍使用词向量计算），下面这幅图比较好的解释了这种方法的思路。

    ![adsa](/images/word_mover_distance.png)


3. Smooth Inverse Frequency

    前面我们说过，方法1中会忽略句子中很多的信息，这其中就包括句子中每个词的重要性信息。我们知道the, and, but等词对句子z整体的影响是比较小的（从语义上来讲，主语谓语比介词连词有更多的语义信息），而Smooth Inverse Frequency就是利用了这些信息来为剧中的词语设置不同的权重。他的原理类似于TF-IDF。

上面几种方法都利用了词向量信息，而且都没有考虑中句子中的词序信息，但是我们知道词的顺序对句意是有很大影响的。下面介绍的几种不使用词向量的相似度对比方法。这些方法的思路基本上都是直接对句子进行编码（和词向量类似的句向量），他们可以直接把句子编码成向量，在这个过程中包括词序信息在内的各种句子信息都会被考虑进来：


1. [InferSent](https://github.com/facebookresearch/InferSent)

    该算法是一种句子level的embedding算法，由Facebook研究院发明，他是一种基于双向LSTM的网络，使用SNLI数据集通过有监督学习进行训练。

2. GSE，[Google Sentence Encoder](https://www.tensorflow.org/hub/modules/google/universal-sentence-encoder/1)

    Google 提出的一种句子embedding算法，同时使用了有监督学习（SNLI语料）和无监督学习（类似Word2Vec的方法）对模型进行训练，效果略微好于InferSent。


## 性能对比

[这篇文章](http://nlp.town/blog/sentence-similarity/)中包含了一个比较详细的性能对比。总体来说，基准方法（直接使用词向量平均值表示短语）虽然简单，但是效果不错。综合来看，google的GSE效果最好，不过其与其他模型相比优势并不十分明显。


## 补充，使用孪生网络进行句子相似度计算

除了上面介绍的之外，孪生网络也是相似度对比不可不提的一个概念，他很简单，但是很有效果。孪生网络结构如下图所示，使用两个权值共享的网络（两个网络相同）对一对输入进行编码，然后通过计算两个输入编码结果的相似度来判断输入的相似度。这种网络被广泛应用于各种相似度计算任务重中。在进行句子相似度计算可以使用上面介绍的InferSent或者Google sentence encoder作为编码网络来进行相似度的预测。

![孪生网络结构](/images/siamese_network.jpeg?style=center)
